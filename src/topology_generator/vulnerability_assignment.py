"""
Vulnerability assignment and deduplication utilities.

This module assigns concrete vulnerabilities to attack path steps and
deduplicates installations according to each vulnerability's merge strategy.
"""

from __future__ import annotations

import random
from dataclasses import dataclass
from typing import List, Tuple, Set
from uuid import UUID

from src.models import (
    NetworkTopology,
    AttackPath,
    LateralMovementStep,
    PrivilegeEscalationStep,
)
from src.models.vulnerabilities import (
    MergeStrategy,
    ApacheStrutsVulnerability,
    NetcatShellVulnerability,
    MisconfiguredSSHKeysVulnerability,
    SudoBaronVulnerability,
    WriteablePasswdVulnerability,
)


class VulnerabilityAssigner:
    """Randomly assign vulnerabilities to path steps from provided catalogs."""

    def __init__(
        self,
        rng: random.Random | None = None,
    ) -> None:
        # Defaults if not provided
        self.lm_catalog_non_root = [
            ApacheStrutsVulnerability,
            NetcatShellVulnerability,
            MisconfiguredSSHKeysVulnerability,
        ]

        self.lm_initial_access_catalog = [
            ApacheStrutsVulnerability,
            NetcatShellVulnerability,
        ]

        self.lm_catalog_root_ok = [
            NetcatShellVulnerability,
            MisconfiguredSSHKeysVulnerability,
        ]

        self.pe_catalog = [SudoBaronVulnerability, WriteablePasswdVulnerability]
        self.rng = rng or random.Random()

    def assign_for_topology(self, topology: NetworkTopology) -> List[AttackPath]:
        assigned: List[AttackPath] = []
        for path in topology.attack_paths:
            assigned.append(self.assign_for_path(path, topology))
        return assigned

    def assign_for_path(
        self, path: AttackPath, topology: NetworkTopology
    ) -> AttackPath:
        """Assign vulnerabilities in-place for a given path and return it."""
        for step in path.steps:
            if isinstance(step, LateralMovementStep):
                to_user = topology.get_user_by_id(step.to_user_id)
                from_user = topology.get_user_by_id(
                    step.from_user_id, include_attacker=True
                )
                if not to_user:
                    raise Exception(f"User {step.to_user_id} not found")
                if not from_user:
                    raise Exception(f"User {step.from_user_id} not found")

                if step.from_host_id == path.start_host_id:
                    vuln_cls = self.rng.choice(self.lm_initial_access_catalog)
                else:
                    if to_user.username == "root":
                        vuln_cls = self.rng.choice(self.lm_catalog_root_ok)
                    else:
                        vuln_cls = self.rng.choice(self.lm_catalog_non_root)

                to_host = topology.get_host_by_id(step.to_host_id)
                from_host = topology.get_host_by_id(
                    step.from_host_id, include_attacker=True
                )
                if not to_host:
                    raise Exception(f"Host {step.to_host_id} not found")
                if not from_host:
                    raise Exception(f"Host {step.from_host_id} not found")

                # Build kwargs based on declared Pydantic fields
                kwargs_lm: dict = {
                    "to_host_ip": str(to_host.ip_address),
                    "to_user": to_user.username,
                    "from_host_ip": str(from_host.ip_address),
                    "from_user": from_user.username,
                }
                step.vulnerability = vuln_cls(**kwargs_lm)  # type: ignore[arg-type]

            elif isinstance(step, PrivilegeEscalationStep):
                vuln_cls = self.rng.choice(self.pe_catalog)
                host = topology.get_host_by_id(step.host_id)
                if not host:
                    raise Exception(f"Host {step.host_id} not found")
                kwargs_pe: dict = {
                    "to_host_ip": str(host.ip_address),
                }
                step.vulnerability = vuln_cls(**kwargs_pe)  # type: ignore[arg-type]

        path.metadata["vulnerabilities_assigned"] = True
        return path

    def apply_vulnerabilities(
        self, attack_paths: List[AttackPath], topology: NetworkTopology
    ) -> None:
        for path in attack_paths:
            for step in path.steps:
                if step.vulnerability is None:
                    continue
                if isinstance(step, LateralMovementStep):
                    to_host = topology.get_host_by_id(step.to_host_id)
                    if not to_host:
                        raise Exception(f"Host {step.to_host_id} not found")
                    to_host.vulnerabilities.append(step.vulnerability)
                elif isinstance(step, PrivilegeEscalationStep):
                    host = topology.get_host_by_id(step.host_id)
                    if not host:
                        raise Exception(f"Host {step.host_id} not found")
                    host.vulnerabilities.append(step.vulnerability)
